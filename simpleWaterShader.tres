[gd_resource type="MaterialShader" format=1]

[resource]

_code = { "fragment":"// Copyright (c) 2016 Alex Piola.\n//\n// Permission is hereby granted, free of charge, to any person obtaining\n// a copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to\n// the following conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n// IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n// CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n///////////////////////////////////////////////////////////////////////\n\n// DESCRIPTION:\n//This is a simple yet effective water shader for Godot engine\n// it is NOT physically correct and doesn\'t use real reflections due to\n// the current limitations in Godot\'s shading language and renderer.\n\n//normal map used for refraction simulation\n// NOTE: is really important to set this to repeat in the image flags\nuniform texture normalMap; \n//you can also add another teture to use as normal map1, just do something like:\n//uniform texture normalMap1;\n//and use it as the refTex1\n\n//we also load a cubemap, in case the screen texture is unavailable\nuniform cubemap sky;\n//you could also use a sky texture with clouds instead, it would look good enough.\n//uniform texture sky;\n\nuniform color waterColor = vec4(0.6,0.7,0.8,1.0); //base color for the water\nuniform color emissionColor = vec4(0.0,0.0,0.0,1.0); //emission, for effects\nuniform float timeScale = 1.0; //timescale, for wave speed\nuniform float waveScale = 0.02; //the \"weight\" of the texture to make waves\nuniform vec2 wave0Dir = vec2(1.0,1.0); //XY direction for the first wave\nuniform vec2 wave1Dir = vec2(-1.0,-1.0); //XY direction for the second wave\nuniform float texScale0 = 0.5; //texture scaling\nuniform float texScale1 = 0.5; //texture scaling\nuniform float reflectionScale = 4.0; //the scale for the light reflection\n\n//first we get the UV position for our texture into a variable\n//so we can animate it to simulate the waves.\n//we will use two different UVs and animate them indipendently, this will\n//give a nice wave-like effect\nvec2 IN_UV = UV * texScale0;\nvec2 IN_UV1 = UV * texScale1;\n//this will animate our texture, setting timescale to a small value will \n//make the waves slower\nfloat scaledTime = TIME * timeScale;\nIN_UV += wave0Dir * scaledTime;\nIN_UV1 += wave1Dir * scaledTime;\n\n//is now time to map our normal map to UV coordinates and use it to displace the texture.\nvec3 refTex = 2.0 * tex(normalMap, IN_UV).rgb - vec3(1.0,1.0,1.0);\nvec3 refTex1 = 2.0 * tex(normalMap, IN_UV1).rgb - vec3(1.0,1.0,1.0);\n\n//our new \"refracted\" UV will be the screen UV displaced by our texture and scaled by waveScale\nvec2 newUV = SCREEN_UV + (refTex.xy + refTex1.xy) * waveScale;\n//this is indipendent from newUV because the light reflection looks better if its scale is \n//way higher that the waveScale\nvec2 reflUV = SCREEN_UV + (refTex.xy + refTex1.xy) *  reflectionScale;\n\n//let\'s calculate the color from the skybox\n//this isn\'t the most correct projection but looks good enough\nvec3 v = -( INV_CAMERA_MATRIX * VERTEX);\nvec3 skyCol = texcube(sky,vec3(newUV * v.xy,v.z)).rgb * waterColor.rgb;\n//if you want to use a texture instead, see tex(sky,newUV)\n\n//this is a bit of an hack to have our reflections look bumpy in the light shader.\nSHADE_PARAM = max(0.0,dot(normalize(NORMAL),vec3(reflUV,refTex.z)));\n\n//this way looks a bit better but could lead to artifacts\n//DIFFUSE_ALPHA = vec4( texscreen(newUV) * skyCol, waterColor.a);\n\n//this way will only use the water color and the cubemap\n//it requires waveScale to be bigger to look better.\nDIFFUSE_ALPHA = vec4( skyCol, waterColor.a);\n\n//the emission color, to have fancy effects\nEMISSION = emissionColor.rgb;", "fragment_ofs":0, "light":"//just ported this from material.glsl\n//were just adding bumpiness from SHADE_PARAM\n//and added specExp to allow more control\nuniform float specExp = 64.0;\nuniform float specularIntensity = 1.0;\n\nfloat NdotL = max(0.0,dot(NORMAL, LIGHT_DIR));\nvec3 half_vec = normalize(LIGHT_DIR + EYE_VEC);\nfloat eyelight = max(dot(NORMAL,half_vec),0.0);\nLIGHT = LIGHT_DIFFUSE * DIFFUSE * NdotL;\n\n\nif(NdotL > 0.0)\n{\n   LIGHT +=  SHADE_PARAM * LIGHT_SPECULAR * pow(eyelight,specExp) * specularIntensity;\n}", "light_ofs":0, "vertex":"", "vertex_ofs":0 }

